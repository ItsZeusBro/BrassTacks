//There are only so many recursive patterns to choose from
//There are only so many different primitive object patterns to choose from (to construct or destructure)
//Most problems involve an iterator on the length of some structure
//Some involve a permutative approach
//as opposed to coming with custom solutions in an arbitrary way, we can limit the number of ways in which
//you can generate the solution, and use a general set of tools to do it the same way every time
class Recursion{
    constructor(recursionObj){
        
    }

    to(schema){
        return obj
    }

    from(schema){
        //base case, or whatever
    }

    transform(schema){
        return transform
    }

    //arbitrary queries are less arbitrary when schemified in a formal way (schema is inherently recursive)
    query(transform, schema){
        return query
    }



}